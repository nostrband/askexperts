import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import { AskExpertsClient } from "../client/AskExpertsClient.js";
import { LightningPaymentManager } from "../lightning/LightningPaymentManager.js";
import { parseBolt11 } from "../common/bolt11.js";
import { debugMCP, debugError } from "../common/debug.js";
import {
  DEFAULT_DISCOVERY_RELAYS,
  FORMAT_TEXT,
  METHOD_LIGHTNING,
} from "../common/constants.js";
import { Bid, Proof, Quote, Prompt, Replies } from "../client/types.js";
import fs from "fs";
import path from "path";
import { fileURLToPath } from "url";
import { makeTool } from "./utils.js";
import OpenAI from "openai";

/**
 * Interface for ReplyMCP objects returned by askExperts
 */
export interface ReplyMCP {
  expert_pubkey: string;
  content?: string;
  amount_sats?: number;
  error?: string;
}

/**
 * AskExpertsSmartMCP class that extends McpServer and provides a simplified interface
 * for clients to interact with the AskExpertsClient with LLM capabilities
 */
export class AskExpertsSmartMCP extends McpServer {
  private client: AskExpertsClient;
  private paymentManager: LightningPaymentManager;
  private bidMap: Map<string, Bid> = new Map();
  private openai: OpenAI;

  /**
   * Creates a new AskExpertsSmartMCP instance
   *
   * @param nwcString - NWC connection string for payments
   * @param openaiApiKey - OpenAI API key
   * @param openaiBaseUrl - OpenAI base URL
   * @param discoveryRelays - Optional list of discovery relays
   */
  constructor(
    nwcString: string,
    openaiApiKey: string,
    openaiBaseUrl: string,
    discoveryRelays?: string[]
  ) {
    if (!nwcString) {
      throw new Error("NWC connection string is required");
    }

    if (!openaiApiKey) {
      throw new Error("OpenAI API key is required");
    }

    if (!openaiBaseUrl) {
      throw new Error("OpenAI base URL is required");
    }

    // Read version from package.json
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);
    const packageJsonPath = path.resolve(__dirname, "../../../package.json"); // from dist/src/mcp
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf8"));

    super({
      name: "askexpertssmartmcp",
      version: packageJson.version,
      description:
        "An MCP server that allows asking questions to experts with LLM-powered summarization and expert selection.",
    });

    // Create the payment manager
    this.paymentManager = new LightningPaymentManager(nwcString);

    // Create the client with callbacks for quotes and payments
    this.client = new AskExpertsClient({
      discoveryRelays: discoveryRelays || DEFAULT_DISCOVERY_RELAYS,
    });

    // Initialize OpenAI
    this.openai = new OpenAI({
      apiKey: openaiApiKey,
      baseURL: openaiBaseUrl,
      defaultHeaders: {
        "HTTP-Referer": "https://askexperts.io", // Site URL for rankings on openrouter.ai
        "X-Title": "AskExperts", // Site title for rankings on openrouter.ai
      },
    });

    // Register tools
    this.registerTools();
  }

  /**
   * Register all tools with the MCP server
   */
  private registerTools(): void {
    // Schema for askExperts tool
    const askExpertsConfig = {
      title: "Ask Experts",
      description:
        "Ask a question to experts. The question should be detailed and may include sensitive data as it is encrypted. Provide max amount of payment you are willing to pay to each expert, good default is 100 sats.",
      inputSchema: {
        question: z.string().describe("The question to ask the experts"),
        max_amount_sats: z
          .number()
          .describe("Maximum amount to pay in satoshis"),
        hashtags: z
          .array(z.string())
          .optional()
          .describe("Optional hashtags to append to the ones generated by AI"),
      },
      outputSchema: {
        replies: z
          .array(
            z.object({
              expert_pubkey: z.string().describe("Expert's public key"),
              content: z.string().optional().describe("Content of the answer"),
              amount_sats: z.number().optional().describe("Amount paid in satoshis"),
              error: z.string().optional().describe("Error message if the expert request failed"),
            })
          )
          .describe("Array of replies from experts"),
      },
      annotations: {
        title: "Ask experts a question and receive their answers",
        readOnlyHint: false,
        destructiveHint: false,
        idempotentHint: false,
        openWorldHint: true,
      },
    };

    // Register the askExperts tool
    this.registerTool(
      "ask_experts",
      askExpertsConfig,
      makeTool(async (params, extra) => {
        const { question, max_amount_sats, hashtags } = params;
        const replies = await this.askExperts(question, max_amount_sats, hashtags);
        return { replies };
      })
    );
  }

  /**
   * Handles quote events from experts
   *
   * @param quote - Quote from expert
   * @param prompt - Prompt sent to expert
   * @param max_amount_sats - Maximum amount to pay in satoshis
   * @returns Promise resolving to the invoice amount if it's within max_amount_sats, otherwise 0
   * @private
   */
  private async handleQuote(
    quote: Quote,
    prompt: Prompt,
    max_amount_sats: number
  ): Promise<number> {
    // Check if there's a lightning invoice
    const lightningInvoice = quote.invoices.find(
      (inv) => inv.method === "lightning"
    );

    if (!lightningInvoice || !lightningInvoice.invoice) {
      debugError("No lightning invoice found in quote");
      return 0;
    }

    // Parse the invoice to get the amount
    try {
      const { amount_sats } = parseBolt11(lightningInvoice.invoice);

      // Check if the amount is within the max amount
      if (amount_sats <= max_amount_sats) {
        return amount_sats;
      } else {
        debugMCP(
          `Invoice amount (${amount_sats}) exceeds max amount (${max_amount_sats})`
        );
        return 0;
      }
    } catch (error) {
      debugError("Failed to parse invoice:", error);
      return 0;
    }
  }

  /**
   * Handles payment for quotes
   *
   * @param quote - Quote from expert
   * @param prompt - Prompt sent to expert
   * @returns Promise resolving to Proof object
   * @private
   */
  private async handlePayment(quote: Quote, prompt: Prompt): Promise<Proof> {
    // Find the lightning invoice
    const lightningInvoice = quote.invoices.find(
      (inv) => inv.method === "lightning"
    );

    if (!lightningInvoice || !lightningInvoice.invoice) {
      throw new Error("No lightning invoice found in quote");
    }

    try {
      // Pay the invoice using the payment manager
      const preimage = await this.paymentManager.payInvoice(
        lightningInvoice.invoice
      );

      // Return the proof
      return {
        method: "lightning",
        preimage,
      };
    } catch (error) {
      throw new Error(
        `Payment failed: ${
          error instanceof Error ? error.message : String(error)
        }`
      );
    }
  }

  /**
   * Asks experts a question with LLM-powered summarization and expert selection
   *
   * @param question - Question to ask
   * @param max_amount_sats - Maximum amount to pay in satoshis
   * @param user_hashtags - Optional array of hashtags to append to the ones generated by AI
   * @returns Promise resolving to array of ReplyMCP objects
   */
  async askExperts(
    question: string,
    max_amount_sats: number,
    user_hashtags?: string[]
  ): Promise<ReplyMCP[]> {
    if (!question || question.trim() === "") {
      throw new Error("Question is required");
    }

    if (max_amount_sats <= 0) {
      throw new Error("Maximum amount must be greater than zero");
    }

    // Parse question, prepare for findExperts call
    let publicQuestionSummary: string | undefined;
    let hashtags: string[] = [];

    try {
      // Use OpenAI to generate an answer
      const completion = await this.openai.chat.completions.create({
        model: "openai/gpt-4o-mini",
        messages: [
          {
            role: "system",
            content: `Your job is to look at the user's detailed question or prompt that might include sensitive or private information, 
and come up with a short anonymized summarized version that can be shared publicly to find experts on the subject, without revealing
any private data. You must also determine 1 to 10 hashtags that this summarized question/prompt might have to simplify discovery for experts - hashtags
must be one word each, english, lowercase, and be as specific as possible. If the question is super simple and looks like a test, come up with appropriate
hashtags but don't summarize the question - just return the input question as summarized one, don't invent your own question/summary.

Reply in a structured way in two lines:
\`\`\`
hashtags: hashtag1, hashtag2, etc
question: <summarized question>
\`\`\`
`,
// commented, doesn't work well:
// If you believe the question/prompt is malformed or makes no sense, reply with one word "verbatim".
          },
          {
            role: "user",
            content: question,
          },
        ],
      });

      // Extract the response content
      const responseContent = completion.choices[0]?.message?.content;
      debugMCP("prepare ask responseContent", { responseContent, question });
      if (!responseContent || responseContent === "error")
        throw new Error("Failed to parse the question");
      const lines = responseContent
        .split("\n")
        .map((s) => s.trim())
        .filter((s) => !!s);
      if (
        lines.length !== 2 ||
        !lines[0].startsWith("hashtags: ") ||
        !lines[1].startsWith("question: ")
      )
        throw new Error("Bad question parsing reply");

      hashtags = lines[0].substring("hashtags: ".length)
        .split(",")
        .map((t) => t.trim())
        .filter((t) => !!t);
      
      // Append user-provided hashtags if they exist
      if (user_hashtags && user_hashtags.length > 0) {
        hashtags = [...hashtags, ...user_hashtags];
      }
      
      publicQuestionSummary = lines[1].substring("question: ".length).trim();
    } catch (error) {
      debugError("Error processing ask with OpenAI:", error);
      throw error;
    }

    if (!hashtags.length || !publicQuestionSummary)
      throw new Error("Parsed question or hashtags empty");

    // Find experts using the client
    const bids = await this.client.findExperts({
      summary: publicQuestionSummary,
      hashtags,
      formats: [FORMAT_TEXT],
      methods: [METHOD_LIGHTNING],
    });

    if (!bids || bids.length === 0) {
      throw new Error("No experts found for the question");
    }

    // For now, just use all bids
    // TODO: Implement bid evaluation using OpenAI
    const selectedBids = bids;

    // Store bids in the map for later use
    this.bidMap.clear();
    for (const bid of selectedBids) {
      this.bidMap.set(bid.id, bid);
    }

    const results: ReplyMCP[] = [];

    // Process each bid in parallel
    const promiseResults = await Promise.allSettled(
      selectedBids.map(async (bid) => {
        // Ask the expert
        return this.askExpertInternal(
          question,
          bid,
          max_amount_sats
        );
      })
    );

    // Process the results, including errors
    promiseResults.forEach((result, index) => {
      if (result.status === 'fulfilled') {
        // Add successful result to the array
        results.push(result.value);
      } else {
        // Create an error reply
        const errorMessage = result.reason instanceof Error
          ? result.reason.message
          : String(result.reason);
        
        debugError(`Failed to ask expert ${selectedBids[index].pubkey}:`, result.reason);
        
        // Add error reply to results
        results.push({
          expert_pubkey: selectedBids[index].pubkey,
          error: `Failed to ask expert: ${errorMessage}`
        });
      }
    });

    return results;
  }

  /**
   * Internal method to ask an expert a question
   *
   * @param question - Question to ask
   * @param bid - Bid object
   * @param max_amount_sats - Maximum amount to pay in satoshis
   * @returns Promise resolving to ReplyMCP object
   * @private
   */
  private async askExpertInternal(
    question: string,
    bid: Bid,
    max_amount_sats: number
  ): Promise<ReplyMCP> {
    try {
      // Track the invoice amount
      let invoice_amount = 0;

      // Ask the expert using the client
      const replies: Replies = await this.client.askExpert({
        bid,
        content: question,
        format: FORMAT_TEXT,
        compr: bid.compressions[0],
        onQuote: async (quote, prompt) => {
          // Call our handleQuote method with the max amount
          const amount = await this.handleQuote(quote, prompt, max_amount_sats);

          // Store the amount for later use
          invoice_amount = amount;

          // Return true if the amount is greater than 0
          return amount > 0;
        },
        onPay: (quote, prompt) => this.handlePayment(quote, prompt),
      });

      // Process the replies
      let content = "";

      // Iterate through the replies
      for await (const reply of replies) {
        // Append the content
        if (typeof reply.content === "string") {
          content += reply.content;
        } else {
          content += JSON.stringify(reply.content);
        }
      }

      // Return the ReplyMCP object
      return {
        expert_pubkey: bid.pubkey,
        content,
        amount_sats: invoice_amount,
      };
    } catch (error) {
      throw new Error(
        `Failed to ask expert: ${
          error instanceof Error ? error.message : String(error)
        }`
      );
    }
  }

  /**
   * Disposes of resources when the object is no longer needed
   */
  [Symbol.dispose](): void {
    // Dispose of the client
    this.client[Symbol.dispose]();

    // Dispose of the payment manager
    this.paymentManager[Symbol.dispose]();

    // Stop itself
    this.close().catch(() => debugError("Failed to close the MCP server"));
  }
}